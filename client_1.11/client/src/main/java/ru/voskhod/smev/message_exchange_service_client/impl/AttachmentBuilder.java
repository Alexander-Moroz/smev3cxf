package ru.voskhod.smev.message_exchange_service_client.impl;

import it.sauronsoftware.ftp4j.*;
import org.apache.commons.codec.binary.Base64;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.voskhod.crypto.PipeInputStream;
import ru.voskhod.crypto.exceptions.SignatureProcessingException;
import ru.voskhod.smev.message_exchange.autogenerated.types.basic.v1_1.*;
import ru.voskhod.smev.message_exchange_service_client.*;

import javax.activation.DataHandler;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

public final class AttachmentBuilder {

    private static final Logger logger = LoggerFactory.getLogger(AttachmentBuilder.class);

    private static final int MAX_ATTEMPTS = 3;

    private final String ftpAddress;
    private final SignatureOperationsClient ovSigner;
    private final long directLimit;

    private final List<RefAttachmentHeaderType> ftpHeaders = new ArrayList<>();
    private final List<AttachmentContentType> directContents = new ArrayList<>();
    private final List<AttachmentHeaderType> directHeaders = new ArrayList<>();

    public AttachmentBuilder(String ftpAddress, SignatureOperationsClient ovSigner, long directLimit) {
        this.ftpAddress = ftpAddress;
        this.ovSigner = ovSigner;
        this.directLimit = directLimit;
    }

    private void sendDirect(InAttachment attachment, DigestResult digest) throws SignatureProcessingException, IOException {
        byte[] signature;
        if (attachment.getPersonalSignature() == null) {
            if (digest == null) {
                digest = attachment.getDigest();
            }
            signature = ovSigner.signPKCS7Detached(digest.getDataDigest());
        } else {
            signature = attachment.getPersonalSignature();
        }

        AttachmentHeaderType ah = new AttachmentHeaderType();
        ah.setContentId(attachment.getId());
        ah.setMimeType(attachment.getMimeType());
        ah.setSignaturePKCS7(signature);
        directHeaders.add(ah);

        AttachmentContentType ac = new AttachmentContentType();
        ac.setId(attachment.getId());
        ac.setContent(new DataHandler(new AttachmentDataSourceImpl(attachment)));
        directContents.add(ac);
    }

    private static <T extends Exception> void checkAttempt(int attempt, T ex) throws T {
        logger.warn("Ошибка закачки", ex);
        if (attempt >= MAX_ATTEMPTS - 1) {
            throw ex;
        }
    }

    public static void connect(FTPClient ftp, String address) throws FTPException, IOException, FTPIllegalReplyException {
        int p = address.lastIndexOf(':');
        if (p < 0) {
            ftp.connect(address);
        } else {
            String host = address.substring(0, p);
            String portStr = address.substring(p + 1);
            int port;
            try {
                port = Integer.parseInt(portStr);
            } catch (NumberFormatException nfex) {
                throw new IOException("Номер порта FTP (" + portStr + ") не является числом", nfex);
            }
            ftp.connect(host, port);
        }
    }

    private DigestResult uploadToFTP(String uuid, String fileName, InAttachment attachment) throws FTPException, IOException, FTPIllegalReplyException, FTPDataTransferException, FTPAbortedException, SignatureProcessingException {
        for (int attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
            try {
                FTPClient ftp = new FTPClient();
                connect(ftp, ftpAddress);
                boolean ok = false;
                try {
                    ftp.login("anonymous", "smev");
                    try {
                        ftp.createDirectory(uuid);
                    } catch (FTPException ex) {
                        if (attempt == 0) {
                            logger.warn("Невозможно создать папку FTP", ex);
                        }
                    }
                    ftp.changeDirectory(uuid);
                    PipeInputStream pipeStream;
                    try (InputStream inputStream = attachment.getInputStream()) {
                        pipeStream = SignatureOperationsClient.getDigestCollectingInputStream(inputStream);
                        long currentSize = 0;
                        boolean createNew;
                        if (attempt == 0) {
                            createNew = true;
                        } else {
                            try {
                                currentSize = ftp.fileSize(fileName);
                                createNew = false;
                            } catch (FTPException ex) {
                                createNew = true;
                                logger.warn("Невозможно получить размер файла", ex);
                            }
                        }
                        if (createNew) {
                            ftp.upload(fileName, pipeStream, 0, 0, null);
                        } else {
                            ftp.append(fileName, pipeStream, currentSize, null);
                        }
                        ok = true;
                    }
                    return new DigestResult(pipeStream);
                } finally {
                    try {
                        ftp.disconnect(ok);
                    } catch (Exception ex) {
                        logger.warn("Cannot disconnect from FTP", ex);
                    }
                }
            } catch (FTPException ex) {
                checkAttempt(attempt, ex);
            } catch (FTPIllegalReplyException ex) {
                checkAttempt(attempt, ex);
            } catch (IOException ex) {
                checkAttempt(attempt, ex);
            } catch (FTPDataTransferException ex) {
                checkAttempt(attempt, ex);
            }
        }
        throw new IllegalStateException();
    }

    private void sendFTP(InAttachment attachment) throws SignatureProcessingException, ClientSideProcessingException {
        String attachmentId = attachment.getId();
        String uuid = MessageExchangeHelper.generateUUID();
        try {
            DigestResult digestResult = uploadToFTP(uuid, attachmentId, attachment);

            RefAttachmentHeaderType fh = new RefAttachmentHeaderType();
            fh.setUuid(uuid);
            byte[] digest = digestResult.getDataDigest();
            fh.setHash(Base64.encodeBase64String(digest));
            fh.setMimeType(attachment.getMimeType());
            byte[] signature;
            if (attachment.getPersonalSignature() == null) {
                signature = ovSigner.signPKCS7Detached(digest);
            } else {
                signature = attachment.getPersonalSignature();
            }
            fh.setSignaturePKCS7(signature);
            ftpHeaders.add(fh);
        } catch (IOException ex) {
            throw new ClientSideProcessingException(ex);
        } catch (FTPException ex) {
            throw new ClientSideProcessingException(ex);
        } catch (FTPIllegalReplyException ex) {
            throw new ClientSideProcessingException(ex);
        } catch (FTPAbortedException ex) {
            throw new ClientSideProcessingException(ex);
        } catch (FTPDataTransferException ex) {
            throw new ClientSideProcessingException(ex);
        }
    }

    public void attach(List<InAttachment> attachments) throws ClientSideProcessingException {
        try {
            List<DigestResult> digests = new ArrayList<>();
            long totalSize = 0;
            int attachmentCount = 0;
            for (InAttachment attachment : attachments) {
                if (attachment.getId() == null) {
                    attachment.setId("__ATT_ID_SMEV_C_AUTOGEN__" + (++attachmentCount));
                }
                Long length = attachment.getLength();
                DigestResult digest;
                if (length == null) {
                    digest = attachment.getDigest();
                    totalSize += digest.getDataSize();
                } else {
                    digest = null;
                    totalSize += length.longValue();
                }
                digests.add(digest);
            }

            if (totalSize > directLimit) {
                for (InAttachment attachment : attachments) {
                    sendFTP(attachment);
                }
            } else {
                for (int i = 0; i < attachments.size(); i++) {
                    InAttachment attachment = attachments.get(i);
                    sendDirect(attachment, digests.get(i));
                }
            }
        } catch (SignatureProcessingException ex) {
            throw new ClientSideProcessingException(ex);
        } catch (IOException ex) {
            throw new ClientSideProcessingException(ex);
        }
    }

    public InAttachments getResult() {
        AttachmentHeaderList headerList;
        AttachmentContentList contentList;
        if (directHeaders.size() > 0) {
            headerList = new AttachmentHeaderList();
            headerList.getAttachmentHeader().addAll(directHeaders);
            contentList = new AttachmentContentList();
            contentList.getAttachmentContent().addAll(directContents);
        } else {
            headerList = null;
            contentList = null;
        }
        RefAttachmentHeaderList fsAttachmentsList;
        if (ftpHeaders.size() > 0) {
            fsAttachmentsList = new RefAttachmentHeaderList();
            fsAttachmentsList.getRefAttachmentHeader().addAll(ftpHeaders);
        } else {
            fsAttachmentsList = null;
        }
        return new InAttachments(headerList, contentList, fsAttachmentsList);
    }
}
