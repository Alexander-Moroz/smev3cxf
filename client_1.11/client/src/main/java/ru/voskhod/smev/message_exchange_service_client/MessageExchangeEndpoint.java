package ru.voskhod.smev.message_exchange_service_client;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import ru.voskhod.smev.message_exchange.autogenerated.service.v1_1.*;
import ru.voskhod.smev.message_exchange.autogenerated.types.basic.v1_1.*;
import ru.voskhod.smev.message_exchange.autogenerated.types.basic.v1_1.Void;
import ru.voskhod.smev.message_exchange.autogenerated.types.v1_1.*;
import ru.voskhod.smev.message_exchange.autogenerated.types.v1_1.GetRequestResponse.RequestMessage;
import ru.voskhod.smev.message_exchange.autogenerated.types.v1_1.GetResponseResponse.ResponseMessage;
import ru.voskhod.smev.message_exchange.autogenerated.types.v1_1.SenderProvidedResponseData.RequestRejected;
import ru.voskhod.smev.message_exchange_service_client.datatypes.MessageMetaDataAndSMEVSignature;
import ru.voskhod.smev.message_exchange_service_client.datatypes.QueueStatistics;
import ru.voskhod.smev.message_exchange_service_client.impl.AttachmentBuilder;
import ru.voskhod.smev.message_exchange_service_client.impl.InAttachments;
import ru.voskhod.smev.message_exchange_service_client.impl.LargeOutAttachment;
import ru.voskhod.smev.message_exchange_service_client.impl.SmallOutAttachment;
import ru.voskhod.crypto.exceptions.SignatureProcessingException;
import ru.voskhod.crypto.exceptions.SignatureValidationException;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.namespace.QName;
import javax.xml.transform.dom.DOMResult;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.WebServiceException;
import javax.xml.ws.soap.SOAPBinding;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.PrivateKey;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509Certificate;
import java.util.*;

/**
 * Точка доступа к сервису обмена сообщениями СМЭВ.
 * Потокобезопасна.
 * Перед использованием - инжектить секретный ключ и репозиторий сертификатов.
 * @author dpryakhin
 */
public class MessageExchangeEndpoint {

    private static final QName SERVICE_QNAME = new QName("urn://x-artefacts-smev-gov-ru/services/message-exchange/1.1", "SMEVMessageExchangeService");

    public static final String SIGNATURE_ID_CONSUMER = "SIGNED_BY_CONSUMER";
    public static final String SIGNATURE_ID_PROVIDER = "SIGNED_BY_PROVIDER";
    public static final String SIGNATURE_ID_CALLER = "SIGNED_BY_CALLER";

    private static final Logger logger = LoggerFactory.getLogger(MessageExchangeEndpoint.class);

    private static final ThreadLocal<DatatypeFactory> datatypeFactoryHolder = new ThreadLocal<DatatypeFactory>() {
        @Override
        protected DatatypeFactory initialValue() {
            try {
                return DatatypeFactory.newInstance();
            } catch (DatatypeConfigurationException e) {
                throw new RuntimeException(e);
            }
        }
    };

    private static final ThreadLocal<JAXBContext> jaxbContext = new ThreadLocal<JAXBContext>() {
        @Override
        protected JAXBContext initialValue() {
            try {
                return JAXBContext.newInstance("ru.voskhod.smev.message_exchange.autogenerated.types.v1_1");
            } catch (JAXBException e) {
                throw new RuntimeException(e);
            }
        }
    };

    private final SMEVMessageExchangePortType port;
    private final String ftpAddress;
    private final SignatureOperationsClient ovSigner;
    private final long directLimit;

    public MessageExchangeEndpoint(SMEVMessageExchangePortType port,
                                   String ftpAddress,
                                   SignatureOperationsClient ovSigner,
                                   long directLimit) {
        this.port = port;
        this.ftpAddress = ftpAddress;
        this.ovSigner = ovSigner;
        this.directLimit = directLimit;
    }

    /**
     * Сгенерировать ID для нового сообщения.
     * Этот ID нужно будет передавать первым параметром методам sendRequest, sendResponse.
     * Если в ходе передачи сообщения HTTP-соединение разорвалось,
     * повторную передачу нужно делать с тем же message ID.
     */
    public String generateMessageID() {
        return MessageExchangeHelper.generateUUID();
    }

    /**
     * Создать СМЭВ-сервис обмена сообщениями.
     * @param smevUrl URL, по которому сервис экспонирует свой WSDL, в виде строки.
     * @param ftpAddress адрес хранилища файлов FTP в виде "хост[:порт]"
     * @param ovPrivateKey секретный ключ для ЭП-ОВ
     * @param ovCertificate сертификат ЭП-ОВ
     * @throws MalformedURLException URL не валиден.
     */
    public static MessageExchangeEndpoint create(String smevUrl,
                                                 String ftpAddress,
                                                 PrivateKey ovPrivateKey,
                                                 X509Certificate ovCertificate) throws MalformedURLException, WebServiceClientException {
        return create(smevUrl, ftpAddress, new SignatureOperationsClient(ovPrivateKey, ovCertificate), 5 * 1024 * 1024);
    }

    /**
     * Создать СМЭВ-сервис обмена сообщениями.
     * @param smevUrl URL, по которому сервис экспонирует свой WSDL, в виде строки.
     * @param ftpAddress адрес хранилища файлов FTP в виде "хост[:порт]"
     * @param ovSigner подпись ЭП-ОВ
     * @param directLimit лимит на суммарный объем файлов, передаваемых в СМЭВ напрямую (не через FTP)
     * @throws MalformedURLException URL не валиден.
     */
    public static MessageExchangeEndpoint create(String smevUrl,
                                                 String ftpAddress,
                                                 SignatureOperationsClient ovSigner,
                                                 long directLimit) throws MalformedURLException, WebServiceClientException {
        return new MessageExchangeEndpoint(createPort(smevUrl), ftpAddress, ovSigner, directLimit);
    }

    /**
     * @param smevUrl URL, по которому сервис экспонирует свой WSDL, в виде строки.
     * @throws MalformedURLException URL не валиден.
     */
    public static SMEVMessageExchangePortType createPort(String smevUrl) throws MalformedURLException, WebServiceClientException {
        try {
            logger.debug("Obtaining WS connection");
            SMEVMessageExchangeService service = new SMEVMessageExchangeService(new URL(smevUrl), SERVICE_QNAME);

            SMEVMessageExchangePortType port = service.getSMEVMessageExchangeEndpoint();
            ((BindingProvider) port).getRequestContext().put("com.sun.xml.ws.connect.timeout", 5 * 1000);

            SOAPBinding binding = (SOAPBinding)((BindingProvider) port).getBinding();
            binding.setMTOMEnabled(true);
            return port;
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
    }

    public static Marshaller getJAXBMarshaller() throws JAXBException {
        return jaxbContext.get().createMarshaller();
    }

    /**
     * Послать запрос.
     * @param content бизнес-данные запроса.
     * @param signPersonal true, если надо подписывать бизнес-данные ЭП-СП (если ЭП-СП задана).
     * @param businessProcessMetadata Метаданные бизнес-процесса, в рамках которого посылается запрос.
     * См. схему urn://x-artefacts-smev-gov-ru/services/message-exchange/business-process-metadata/1.0.
     * Для работы с метаданными есть helper class - BusinessProcessMetadataBuilder.
     * @param attachmentList приложенные файлы. Можно null, если нет вложений.
     *
     * @return метаданные сообщения, в том числе ID, присвоенный сообщению СМЭВ.
     *
     * @throws SignatureVerificationFaultException ЭП-ОВ не прошла верификацию, либо отсутствует.
     * @throws SenderIsNotRegisteredException сертификат, входящий в состав ЭП-ОВ,
     *  не зарегистрирован в СМЭВ.
     * @throws SMEVFailureException сбой в работе СМЭВ.
     * @throws RecipientIsNotFoundException невозможно идентифицировать получателя сообщения.
     *  Наиболее вероятная причина - неверно указан namespace бизнес-данных
     *  (//SenderProvidedRequestData/MessagePrimaryContent/element()).
     * @throws InvalidContentException бизнес-данные не прошли валидацию по схеме.
     * @throws BusinessDataTypeIsNotSupportedException схема для бизнес-данных
     *   не зарегистрирована в СМЭВ.
     * @throws AttachmentSizeLimitExceededException превышен максимально допустимый размер вложений.
     * @throws AccessDeniedException согласно матрице доступа СМЭВ, вашей ИС
     *   не разрешено посылать запросы такого типа.
     * @throws DestinationOverflowException входящая очередь поставщика данных переполнена.
     * @throws ClientSideProcessingException ошибка клиентской библиотеки СМЭВ.
     */
    public MessageMetaDataAndSMEVSignature sendRequest(String messageId,
                                                       Element content,
                                                       PersonalSigner signPersonal,
                                                       List<Element> businessProcessMetadata,
                                                       List<InAttachment> attachmentList)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            RecipientIsNotFoundException,
            InvalidContentException,
            BusinessDataTypeIsNotSupportedException,
            AttachmentContentMiscoordinationException,
            AttachmentSizeLimitExceededException,
            QuoteLimitExceededException,
            AccessDeniedException,
            DestinationOverflowException,
            ClientSideProcessingException,
            MessageIsAlreadySentException,
            InvalidMessageIdFormatException,
            StaleMessageIdException,
            WebServiceClientException {
        return sendRequestInternal(messageId, content, signPersonal, businessProcessMetadata, attachmentList, false);
    }

    /**
     * Послать тестовый запрос.
     */
    public MessageMetaDataAndSMEVSignature sendTestRequest(String messageId,
                                                           Element content,
                                                           PersonalSigner signPersonal,
                                                           List<Element> businessProcessMetadata,
                                                           List<InAttachment> attachmentList)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            RecipientIsNotFoundException,
            InvalidContentException,
            BusinessDataTypeIsNotSupportedException,
            AttachmentContentMiscoordinationException,
            AttachmentSizeLimitExceededException,
            QuoteLimitExceededException,
            AccessDeniedException,
            DestinationOverflowException,
            ClientSideProcessingException,
            MessageIsAlreadySentException,
            InvalidMessageIdFormatException,
            StaleMessageIdException,
            WebServiceClientException {
        return sendRequestInternal(messageId, content, signPersonal, businessProcessMetadata, attachmentList, true);
    }

    private MessageMetaDataAndSMEVSignature sendRequestInternal(String messageId,
                                                                Element content,
                                                                PersonalSigner signPersonal,
                                                                List<Element> businessProcessMetadata,
                                                                List<InAttachment> attachmentList,
                                                                boolean testMessageFlag)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            RecipientIsNotFoundException,
            InvalidContentException,
            BusinessDataTypeIsNotSupportedException,
            AttachmentContentMiscoordinationException,
            AttachmentSizeLimitExceededException,
            QuoteLimitExceededException,
            AccessDeniedException,
            DestinationOverflowException,
            ClientSideProcessingException,
            MessageIsAlreadySentException,
            InvalidMessageIdFormatException,
            StaleMessageIdException,
            WebServiceClientException {

        long ts1 = System.currentTimeMillis();

        SenderProvidedRequestData requestButAttachments = new SenderProvidedRequestData();
        requestButAttachments.setMessageID(messageId);
        requestButAttachments.setId(SIGNATURE_ID_CONSUMER);

        // Положим ЭП-СП, если есть.
        if (signPersonal != null) {
            XMLDSigSignatureType signature = createPersonalSignature(signPersonal, content);
            requestButAttachments.setPersonalSignature(signature);
        }

        // Положим XML-контент.
        MessagePrimaryContent businessDataWrapper = new MessagePrimaryContent();
        businessDataWrapper.setAny(content);
        requestButAttachments.setMessagePrimaryContent(businessDataWrapper);

        // Флаг тестового сообщения: если сообщение не тестовое, он отсутствует.
        if (testMessageFlag) {
            Void testMessageTag = new Void();
            requestButAttachments.setTestMessage(testMessageTag);
        }

        // Информация о бизнес-процессе: если она не передана,
        // элемент BusinessProcessMetadata отсутствует.
        if (businessProcessMetadata != null) {
            SenderProvidedRequestData.BusinessProcessMetadata bpMetadataWrapper = new SenderProvidedRequestData.BusinessProcessMetadata();
            bpMetadataWrapper.getAny().addAll(businessProcessMetadata);
            requestButAttachments.setBusinessProcessMetadata(bpMetadataWrapper);
        }

        SendRequestRequest paramWrapper = new SendRequestRequest();
        paramWrapper.setSenderProvidedRequestData(requestButAttachments);

        // Обработать вложения. Нужно сделать:
        // 1. Сделать отдельные блоки заголовков и содержимого.
        // 2. Если у вложений нет ID, сгенерировать их.
        // 3. Если вложения не подписаны ЭП-СП, подписать их ЭП-ОВ.
        long ts2 = System.currentTimeMillis();
        InAttachments attachmentsInterim = internalizeAttachments(attachmentList);
        requestButAttachments.setAttachmentHeaderList(attachmentsInterim.headerList);
        requestButAttachments.setRefAttachmentHeaderList(attachmentsInterim.fsAttachmentsList);
        paramWrapper.setAttachmentContentList(attachmentsInterim.contentList);

        long ts3 = System.currentTimeMillis();
        // Подписать ЭП-ОВ. Подписываем всё, включая заголовки вложений, но не содержимое вложений.
        // Так делается потому, что при любой попытке маршаллинга XML-фрагмента, содержащего MTOM-вложение,
        // MTOM отключается.
        XMLDSigSignatureType signatureWrapper = sign(requestButAttachments);
        paramWrapper.setCallerInformationSystemSignature(signatureWrapper);
        long ts4 = System.currentTimeMillis();

        // Посылаем сообщение.
        sendingRequest(paramWrapper);
        SendRequestResponse response;
        try {
            response = port.sendRequest(paramWrapper);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
        responseReceived(response);
        long ts5 = System.currentTimeMillis();

        logger.debug("Time before signing: {} ms. Attachment processing took {} ms. Signing took {} ms. Sending took {} ms.",
            ts2 - ts1, ts3 - ts2, ts4 - ts3, ts5 - ts4);

        // Вынимаем из ответа метаданные сообщения и ЭП-СМЭВ.
        return new MessageMetaDataAndSMEVSignature(
            response.getMessageMetadata(), response.getSMEVSignature()
        );
    }

    /**
     * Послать ответ на запрос.
     * @param replyToAddress адрес назначания; должен быть взят из getMessageIfAnyResponse.getReplyTo().
     * @param content содержательная часть ответа.
     * @param signPersonal true, если надо подписывать бизнес-данные ЭП-СП (если ЭП-СП задана).
     * @param attachmentList приложенные файлы. Можно null, если нет вложений.
     *
     * @return идентификатор, присвоенный сообщению СМЭВ.
     *
     * @throws SignatureVerificationFaultException ЭП-ОВ не прошла верификацию, либо отсутствует.
     * @throws SenderIsNotRegisteredException сертификат, входящий в состав ЭП-ОВ,
     *  не зарегистрирован в СМЭВ.
     * @throws SMEVFailureException сбой в работе СМЭВ.
     * @throws RecipientIsNotFoundException невозможно идентифицировать получателя сообщения.
     *  Причина - в параметр senderProvidedResponseData.setTo(...) передано неверное значение.
     *  Должно быть передано значение из getMessageIfAnyResponse.getReplyTo();
     * @throws InvalidContentException бизнес-данные не прошли валидацию по схеме.
     * @throws IncorrectResponseContentTypeException согласно реестру типов запросов СМЭВ,
     *  на данный запрос нужно отвечать XML-фрагментом с другим полным именем (qualified name)
     *  корневого элемента.
     * @throws BusinessDataTypeIsNotSupportedException схема для бизнес-данных
     *   не зарегистрирована в СМЭВ.
     * @throws AttachmentSizeLimitExceededException превышен максимально допустимый размер вложений.
     */
    public MessageMetaDataAndSMEVSignature sendResponse(String messageId,
                                                        String replyToAddress,
                                                        Element content,
                                                        PersonalSigner signPersonal,
                                                        List<InAttachment> attachmentList)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            RecipientIsNotFoundException,
            InvalidContentException,
            IncorrectResponseContentTypeException,
            BusinessDataTypeIsNotSupportedException,
            AttachmentContentMiscoordinationException,
            AttachmentSizeLimitExceededException,
            QuoteLimitExceededException,
            DestinationOverflowException,
            ClientSideProcessingException,
            MessageIsAlreadySentException,
            InvalidMessageIdFormatException,
            StaleMessageIdException,
            WebServiceClientException {

        // Адрес, на который слать ответ.
        SenderProvidedResponseData responseButAttachments = new SenderProvidedResponseData();
        responseButAttachments.setMessageID(messageId);
        responseButAttachments.setId(SIGNATURE_ID_PROVIDER);
        responseButAttachments.setTo(replyToAddress);

        // ЭП-СП XML-контента, если есть.
        if (signPersonal != null) {
            XMLDSigSignatureType signature = createPersonalSignature(signPersonal, content);
            responseButAttachments.setPersonalSignature(signature);
        }

        // XML-данные ответа.
        MessagePrimaryContent businessDataWrapper = new MessagePrimaryContent();
        businessDataWrapper.setAny(content);
        responseButAttachments.setMessagePrimaryContent(businessDataWrapper);

        SendResponseRequest paramWrapper = new SendResponseRequest();
        paramWrapper.setSenderProvidedResponseData(responseButAttachments);

        // Обработать вложения. Нужно сделать:
        // 1. Сделать отдельные блоки заголовков и содержимого.
        // 2. Если у вложений нет ID, сгенерировать их.
        // 3. Если вложения не подписаны ЭП-СП, подписать их ЭП-ОВ.
        InAttachments attachmentsInterim = internalizeAttachments(attachmentList);
        responseButAttachments.setAttachmentHeaderList(attachmentsInterim.headerList);
        responseButAttachments.setRefAttachmentHeaderList(attachmentsInterim.fsAttachmentsList);
        paramWrapper.setAttachmentContentList(attachmentsInterim.contentList);

        // Подписать ЭП-ОВ. Подписываем всё, включая заголовки вложений, но не содержимое вложений.
        // Так делается потому, что при любой попытке маршаллинга XML-фрагмента, содержащего MTOM-вложение,
        // MTOM отключается.
        XMLDSigSignatureType signatureWrapper = sign(responseButAttachments);
        paramWrapper.setCallerInformationSystemSignature(signatureWrapper);

        // Посылаем сообщение.
        sendingRequest(paramWrapper);
        SendResponseResponse response;
        try {
            response = port.sendResponse(paramWrapper);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
        responseReceived(response);

        // Вынимаем из ответа метаданные сообщения и ЭП-СМЭВ.
        return new MessageMetaDataAndSMEVSignature(
            response.getMessageMetadata(), response.getSMEVSignature()
        );
    }

    /**
     * Ответить потребителю данных, что его запрос отвергнут поставщиком, с указанием одной причины отказа.
     * @param replyToAddress адрес назначания; должен быть взят из getMessageIfAnyResponse.getReplyTo().
     * @param rejectionReason причина отказа, человекочитаемый текст.
     * @param rejectionReasonCode код причины отказа. Необязателен.
     */
    public void rejectRequest(String messageId, String replyToAddress, String rejectionReason, String rejectionReasonCode)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            RecipientIsNotFoundException,
            InvalidContentException,
            IncorrectResponseContentTypeException,
            BusinessDataTypeIsNotSupportedException,
            AttachmentContentMiscoordinationException,
            AttachmentSizeLimitExceededException,
            QuoteLimitExceededException,
            DestinationOverflowException,
            ClientSideProcessingException,
            MessageIsAlreadySentException,
            InvalidMessageIdFormatException,
            StaleMessageIdException,
            WebServiceClientException {

        RequestRejected rejection = new RequestRejected();
        rejection.setRejectionReason(rejectionReason);
        rejection.setRejectionReasonCode(rejectionReasonCode);
        List<RequestRejected> rejectionReasons = Collections.singletonList(rejection);
        rejectRequest(messageId, replyToAddress, rejectionReasons);
    }

    /**
     * Ответить потребителю данных, что его запрос отвергнут поставщиком, с указанием нескольких причин отказа.
     * @param replyToAddress адрес назначания; должен быть взят из getMessageIfAnyResponse.getReplyTo().
     * @param rejectionReasons причины отказа, структура - см. схему urn://x-artefacts-smev-gov-ru/services/message-exchange/types/1.0.
     *   Для каждой причины обязательно дать текстовое описание, код - не обязательно.
     */
    public void rejectRequest(String messageId, String replyToAddress, List<RequestRejected> rejectionReasons)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            RecipientIsNotFoundException,
            InvalidContentException,
            IncorrectResponseContentTypeException,
            BusinessDataTypeIsNotSupportedException,
            AttachmentContentMiscoordinationException,
            AttachmentSizeLimitExceededException,
            QuoteLimitExceededException,
            DestinationOverflowException,
            ClientSideProcessingException,
            MessageIsAlreadySentException,
            InvalidMessageIdFormatException,
            StaleMessageIdException,
            WebServiceClientException {

        // Адрес, на который слать ответ.
        SenderProvidedResponseData responseButAttachments = new SenderProvidedResponseData();
        responseButAttachments.setId(SIGNATURE_ID_PROVIDER);
        responseButAttachments.setMessageID(messageId);
        responseButAttachments.setTo(replyToAddress);

        // XML-данные ответа.
        responseButAttachments.getRequestRejected().addAll(rejectionReasons);

        SendResponseRequest paramWrapper = new SendResponseRequest();
        paramWrapper.setSenderProvidedResponseData(responseButAttachments);

        // Подписать ЭП-ОВ. Подписываем всё, включая заголовки вложений, но не содержимое вложений.
        // Так делается потому, что при любой попытке маршаллинга XML-фрагмента, содержащего MTOM-вложение,
        // MTOM отключается.
        XMLDSigSignatureType signatureWrapper = sign(responseButAttachments);
        paramWrapper.setCallerInformationSystemSignature(signatureWrapper);

        // Посылаем сообщение.
        sendingRequest(paramWrapper);
        SendResponseResponse response;
        try {
            response = port.sendResponse(paramWrapper);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
        responseReceived(response);
    }

    /**
     * Получить запрос из входящей очереди, если очередь не пуста.
     * @param  requestTypeSelector - тип запроса, который нужно получить.
     *  Выражен в qualified name корневого элемента бизнес-данных запроса.
     * @return JAXB-сгенерированное объектное представление элемента
     *  {urn://x-artefacts-smev-gov-ru/services/message-exchange/types/1.0}GetRequestResponse
     * @throws SignatureVerificationFaultException ЭП-ОВ не прошла верификацию, либо отсутствует.
     * @throws SenderIsNotRegisteredException сертификат, входящий в состав ЭП-ОВ,
     *  не зарегистрирован в СМЭВ.
     * @throws SMEVFailureException сбой в работе СМЭВ.
     * @throws InvalidContentException сбой в работе СМЭВ.
     */
    public GetRequestResponse getRequest(QName requestTypeSelector)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            UnknownMessageTypeException,
            ClientSideProcessingException,
            WebServiceClientException {

        // Подготовить данные для запроса.
        MessageTypeSelector wsMessageTypeSelector = new MessageTypeSelector();
        wsMessageTypeSelector.setId(SIGNATURE_ID_CALLER);
        if (requestTypeSelector != null) {
            wsMessageTypeSelector.setNamespaceURI(requestTypeSelector.getNamespaceURI());
            wsMessageTypeSelector.setRootElementLocalName(requestTypeSelector.getLocalPart());
        }
        wsMessageTypeSelector.setTimestamp(getNow());

        GetRequestRequest wsParameters = new GetRequestRequest();
        wsParameters.setMessageTypeSelector(wsMessageTypeSelector);

        // Подписать данные запроса.
        XMLDSigSignatureType signatureWrapper = sign(wsMessageTypeSelector);
        wsParameters.setCallerInformationSystemSignature(signatureWrapper);

        // Сделать запрос к сервису.
        sendingRequest(wsParameters);
        GetRequestResponse wsResponse;
        try {
            wsResponse = port.getRequest(wsParameters);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
        responseReceived(wsResponse);

        // Провалидировать ЭП-СМЭВ.
        if (wsResponse.getRequestMessage() != null) {
            try {
                validateSMEVSignature(wsResponse.getRequestMessage());
            } catch (SignatureValidationException e) {
                handleSignatureValidationAndProcessingException(e, wsResponse);
                wsResponse.setRequestMessage(null);
            } catch (SignatureProcessingException e) {
                handleSignatureValidationAndProcessingException(e, wsResponse);
                wsResponse.setRequestMessage(null);
            }
        }

        return wsResponse;
    }

    /**
     * Получить ответ из входящей очереди, если очередь не пуста.
     * @param  responseTypeSelector - тип ответа, который нужно получить.
     *  Выражен в qualified name корневого элемента бизнес-данных ответа.
     * @return JAXB-сгенерированное объектное представление элемента
     *  {urn://x-artefacts-smev-gov-ru/services/message-exchange/types/1.0}GetResponseResponse
     * @throws SignatureVerificationFaultException ЭП-ОВ не прошла верификацию, либо отсутствует.
     * @throws SenderIsNotRegisteredException сертификат, входящий в состав ЭП-ОВ,
     *  не зарегистрирован в СМЭВ.
     * @throws SMEVFailureException сбой в работе СМЭВ.
     * @throws InvalidContentException сбой в работе СМЭВ.
     */
    public GetResponseResponse getResponse(QName responseTypeSelector)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            UnknownMessageTypeException,
            ClientSideProcessingException,
            WebServiceClientException {

        // Подготовить данные для запроса.
        MessageTypeSelector wsMessageTypeSelector = new MessageTypeSelector();
        wsMessageTypeSelector.setId(SIGNATURE_ID_CALLER);
        if (responseTypeSelector != null) {
            wsMessageTypeSelector.setNamespaceURI(responseTypeSelector.getNamespaceURI());
            wsMessageTypeSelector.setRootElementLocalName(responseTypeSelector.getLocalPart());
        }
        wsMessageTypeSelector.setTimestamp(getNow());

        GetResponseRequest wsParameters = new GetResponseRequest();
        wsParameters.setMessageTypeSelector(wsMessageTypeSelector);

        // Подписать данные запроса.
        XMLDSigSignatureType signatureWrapper = sign(wsMessageTypeSelector);
        wsParameters.setCallerInformationSystemSignature(signatureWrapper);

        // Сделать запрос к сервису.
        sendingRequest(wsParameters);
        GetResponseResponse wsResponse;
        try {
            wsResponse = port.getResponse(wsParameters);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
        responseReceived(wsResponse);

        // Провалидировать ЭП-СМЭВ.
        if (wsResponse.getResponseMessage() != null) {
            try {
                validateSMEVSignature(wsResponse.getResponseMessage());
            } catch (SignatureValidationException e) {
                handleSignatureValidationAndProcessingException(e, wsResponse);
                wsResponse.setResponseMessage(null);
            } catch (SignatureProcessingException e) {
                handleSignatureValidationAndProcessingException(e, wsResponse);
                wsResponse.setResponseMessage(null);
            }
        }

        return wsResponse;
    }

    /**
     * Подтверждение получения сообщения.
     * @param messageData объект, возвращённый методом getMessage, чьё получение нужно подтвердить.
     *
     * @throws SignatureVerificationFaultException ЭП-ОВ не прошла верификацию, либо отсутствует.
     * @throws SenderIsNotRegisteredException сертификат, входящий в состав ЭП-ОВ,
     *  не зарегистрирован в СМЭВ.
     * @throws SMEVFailureException сбой в работе СМЭВ.
     * @throws InvalidContentException сбой в работе СМЭВ.
     */
    public void ack(GetRequestResponse messageData)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            ClientSideProcessingException,
            TargetMessageIsNotFoundException,
            WebServiceClientException {
        ack(messageData, true);
    }

    private void ack(GetRequestResponse messageData, boolean accepted)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            ClientSideProcessingException,
            TargetMessageIsNotFoundException,
            WebServiceClientException {

        if (messageData.getRequestMessage() == null)
            return;
        ack(MessageExchangeHelper.getMessageSMEVId(messageData), accepted);
    }

    public void ack(GetResponseResponse responseResponse)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            TargetMessageIsNotFoundException,
            ClientSideProcessingException,
            WebServiceClientException {
        ack(responseResponse, true);
    }

    public void ack(String targetMessageId, boolean accepted)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            TargetMessageIsNotFoundException,
            ClientSideProcessingException,
            WebServiceClientException {

        AckTargetMessage targetMessage = new AckTargetMessage();
        targetMessage.setId(SIGNATURE_ID_CALLER);
        targetMessage.setValue(targetMessageId);
        targetMessage.setAccepted(accepted);

        AckRequest request = new AckRequest();
        request.setAckTargetMessage(targetMessage);

        // Подписать данные запроса.
        XMLDSigSignatureType signatureWrapper = sign(targetMessage);
        request.setCallerInformationSystemSignature(signatureWrapper);

        sendingRequest(request);
        try {
            port.ack(request);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
    }

    private void ack(GetResponseResponse messageData, boolean accepted)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            TargetMessageIsNotFoundException,
            ClientSideProcessingException,
            WebServiceClientException {

        if (messageData.getResponseMessage() == null)
            return;
        ack(MessageExchangeHelper.getMessageSMEVId(messageData), accepted);
    }

    /**
     * Получить статистику своей входящей очереди:
     * количество сообщений, находящихся в очереди,
     * время, в течение которого самое старое сообщение находится в очереди,
     * время, в течение которого самое младшее сообщение находится в очереди,
     * среднее время нахождения сообщений в очереди.
     * @throws SignatureVerificationFaultException ЭП-ОВ не прошла верификацию, либо отсутствует.
     * @throws SenderIsNotRegisteredException сертификат, входящий в состав ЭП-ОВ,
     *  не зарегистрирован в СМЭВ.
     * @throws SMEVFailureException сбой в работе СМЭВ.
     * @throws InvalidContentException сбой в работе СМЭВ.
     */
    public List<QueueStatistics> getIncomingQueueStatistics()
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            ClientSideProcessingException,
            WebServiceClientException {

        Timestamp ts = new Timestamp();
        ts.setId(SIGNATURE_ID_CALLER);
        ts.setValue(getNow());

        GetIncomingQueueStatisticsRequest wsParameters = new GetIncomingQueueStatisticsRequest();
        wsParameters.setTimestamp(ts);

        // Подписать данные запроса.
        XMLDSigSignatureType signatureWrapper = sign(ts);
        wsParameters.setCallerInformationSystemSignature(signatureWrapper);

        // Сделать запрос к сервису.
        sendingRequest(wsParameters);
        GetIncomingQueueStatisticsResponse wsResponse;
        try {
            wsResponse = port.getIncomingQueueStatistics(wsParameters);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }
        responseReceived(wsResponse);

        // Этот ответ не содержит ЭП-СМЭВ.

        // Преобразовать формат.
        List<QueueStatistics> result = new ArrayList<>();

        for (GetIncomingQueueStatisticsResponse.QueueStatistics wsItem : wsResponse.getQueueStatistics()) {
            String queueName = wsItem.getQueueName();
            long pendingMessages = wsItem.getPendingMessageNumber().longValue();
            QueueStatistics dstItem = new QueueStatistics(queueName, pendingMessages);
            result.add(dstItem);
        }

        return result;
    }

    public GetStatusResponse getStatus()
            throws WebServiceClientException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            UnknownMessageTypeException,
            SignatureVerificationFaultException,
            ClientSideProcessingException {

        Timestamp ts = new Timestamp();
        ts.setId(SIGNATURE_ID_CALLER);
        ts.setValue(getNow());

        GetStatusRequest wsParameters = new GetStatusRequest();
        wsParameters.setTimestamp(ts);

        // Подписать данные запроса.
        XMLDSigSignatureType signatureWrapper = sign(ts);
        wsParameters.setCallerInformationSystemSignature(signatureWrapper);

        // Сделать запрос к сервису.
        sendingRequest(wsParameters);
        GetStatusResponse wsResponse;
        try {
            wsResponse = port.getStatus(wsParameters);
        } catch (WebServiceException ex) {
            throw new WebServiceClientException(ex);
        }

        responseReceived(wsResponse);

        return wsResponse;
    }

    private static XMLGregorianCalendar getNow() {
        GregorianCalendar gc = new GregorianCalendar();
        gc.setTime(new Date());
        return datatypeFactoryHolder.get().newXMLGregorianCalendar(gc);
    }

    private static Element marshal(Object obj) throws JAXBException {
        DOMResult domResult = new DOMResult();
        getJAXBMarshaller().marshal(obj, domResult);
        return ((Document) domResult.getNode()).getDocumentElement();
    }

    private static XMLDSigSignatureType createPersonalSignature(PersonalSigner signPersonal, Element businessContent) throws ClientSideProcessingException {
        try {
            Element personalSignature = signPersonal.getSignature(businessContent);
            XMLDSigSignatureType xmlSignature = new XMLDSigSignatureType();
            xmlSignature.setAny(personalSignature);
            return xmlSignature;
        } catch (SignatureProcessingException ex) {
            throw new ClientSideProcessingException(ex);
        }
    }

    protected XMLDSigSignatureType sign(Object messageButAttachments) throws ClientSideProcessingException {
        try {
            Element content2sign = marshal(messageButAttachments);
            Element signature = ovSigner.signXMLDSigDetached(content2sign, null);
            XMLDSigSignatureType signatureWrapper = new XMLDSigSignatureType();
            signatureWrapper.setAny(signature);
            return signatureWrapper;
        } catch (DOMException exception) {
            throw new ClientSideProcessingException(exception);
        } catch (SignatureProcessingException exception) {
            throw new ClientSideProcessingException(exception);
        } catch (JAXBException exception) {
            throw new ClientSideProcessingException(exception);
        }
    }

    private InAttachments internalizeAttachments(List<InAttachment> attachmentList) throws ClientSideProcessingException {
        AttachmentBuilder builder = new AttachmentBuilder(ftpAddress, ovSigner, directLimit);
        if (attachmentList != null) {
            builder.attach(attachmentList);
        }
        return builder.getResult();
    }

    protected void validateSMEVSignature(RequestMessage message) throws SignatureProcessingException, SignatureValidationException {
        Element smevSignature = message.getSMEVSignature().getAny();
        Element content2validate;
        try {
            Object toMarshal;
            if (message.getRequest() != null) {
                toMarshal = message.getRequest();
            } else {
                toMarshal = message.getCancel();
            }
            content2validate = marshal(toMarshal);
        } catch (JAXBException e) {
            throw new SignatureProcessingException(e);
        }

        Attr attr = content2validate.getAttributeNode("Id");
        if (attr != null) {
            content2validate.setIdAttributeNode(attr, true);
        }

        validateSMEVSignature(smevSignature, content2validate);
    }

    protected void validateSMEVSignature(ResponseMessage message) throws SignatureProcessingException, SignatureValidationException {
        Element smevSignature = message.getSMEVSignature().getAny();
        Element content2validate;
        try {
            content2validate = marshal(message.getResponse());
        } catch (JAXBException e) {
            throw new SignatureProcessingException(e);
        }
        validateSMEVSignature(smevSignature, content2validate);
    }

    protected void validateSMEVSignature(Element smevSignature, Element content2validate) throws SignatureProcessingException, SignatureValidationException {
        if (smevSignature == null)
            throw new SignatureProcessingException("Signature is missing");
        X509Certificate smevCertificate = ovSigner.validateXMLDSigSignature(content2validate, smevSignature);

        // Проверим сертификат СМЭВ на срок действия.
        try {
            smevCertificate.checkValidity();
        } catch (CertificateExpiredException e) {
            throw new SignatureProcessingException("SMEV certificate is expired", e);
        } catch (CertificateNotYetValidException e) {
            throw new SignatureProcessingException("SMEV certificate is not yet valid", e);
        }

        // Проверим сертификат СМЭВ на соответствие тому, который хранится локально.
        try {
            if (!SMEVCertificateStore.getInstance().isKnown(smevCertificate)) {
                throw new SignatureValidationException("SMEV certificate obtained from signature is not identified as one belonging to SMEV");
            }
        } catch (CertificateException e) {
            throw new SignatureProcessingException("SMEV certificate store malfunction", e);
        } catch (IOException e) {
            throw new SignatureProcessingException("SMEV certificate store malfunction", e);
        }
    }

    private void handleSignatureValidationAndProcessingException(Exception exception, Object messageData)
            throws SignatureVerificationFaultException,
            SenderIsNotRegisteredException,
            SMEVFailureException,
            InvalidContentException,
            ClientSideProcessingException,
            WebServiceClientException {
        // Если ЭП-СМЭВ не прошла валидацию, игнорировать сообщение.
        logger.error("SMEV signature validation fault", exception);
        // Подтвердить доставку, чтобы избежать повторной доставки.
        try {
            if (messageData instanceof GetRequestResponse) ack((GetRequestResponse) messageData, false);
            else if (messageData instanceof GetResponseResponse) ack((GetResponseResponse) messageData, false);
        } catch (TargetMessageIsNotFoundException e) {
            throw new ClientSideProcessingException(e);
        }
    }

    public List<OutAttachment> getAttachments(GetRequestResponse response) {
        GetRequestResponse.RequestMessage message = response.getRequestMessage();
        if (message == null)
            return Collections.emptyList();
        Request r = message.getRequest();
        SenderProvidedRequestData data = r.getSenderProvidedRequestData();
        return getAttachments(
            data.getAttachmentHeaderList(), message.getAttachmentContentList(),
            data.getRefAttachmentHeaderList(), r.getFSAttachmentsList()
        );
    }

    public List<OutAttachment> getAttachments(GetResponseResponse response) {
        GetResponseResponse.ResponseMessage message = response.getResponseMessage();
        if (message == null)
            return Collections.emptyList();
        Response r = message.getResponse();
        SenderProvidedResponseData data = r.getSenderProvidedResponseData();
        return getAttachments(
            data.getAttachmentHeaderList(), message.getAttachmentContentList(),
            data.getRefAttachmentHeaderList(), r.getFSAttachmentsList()
        );
    }

    private List<OutAttachment> getAttachments(AttachmentHeaderList attachmentHeaderList, AttachmentContentList attachmentContentList,
                                               RefAttachmentHeaderList fsHeaderList, FSAttachmentsList fsAttachmentsList) {
        List<OutAttachment> attachments = new ArrayList<>();
        if (attachmentContentList != null) {
            List<AttachmentContentType> smallAttachments = attachmentContentList.getAttachmentContent();
            List<AttachmentHeaderType> headers = attachmentHeaderList.getAttachmentHeader();
            for (AttachmentContentType smallAttachment : smallAttachments) {
                AttachmentHeaderType header = null;
                for (AttachmentHeaderType h : headers) {
                    if (h.getContentId().equals(smallAttachment.getId())) {
                        header = h;
                        break;
                    }
                }
                attachments.add(new SmallOutAttachment(header, smallAttachment));
            }
        }
        if (fsAttachmentsList != null) {
            List<FSAuthInfo> largeAttachments = fsAttachmentsList.getFSAttachment();
            List<RefAttachmentHeaderType> headers = fsHeaderList.getRefAttachmentHeader();
            for (FSAuthInfo largeAttachment : largeAttachments) {
                RefAttachmentHeaderType header = null;
                for (RefAttachmentHeaderType h : headers) {
                    if (h.getUuid().equals(largeAttachment.getUuid())) {
                        header = h;
                        break;
                    }
                }
                attachments.add(new LargeOutAttachment(ftpAddress, header, largeAttachment));
            }
        }
        return attachments;
    }

    protected void sendingRequest(Object request) {
    }

    protected void responseReceived(Object response) {
    }

    public SignatureOperationsClient getOV() {
        return ovSigner;
    }
}
