package integration;

import junit.framework.TestCase;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import ru.voskhod.smev.message_exchange.autogenerated.service.v1_1.*;
import ru.voskhod.smev.message_exchange.autogenerated.types.basic.v1_1.MessagePrimaryContent;
import ru.voskhod.smev.message_exchange.autogenerated.types.v1_1.*;
import ru.voskhod.smev.message_exchange_service_client.*;
import ru.voskhod.smev.message_exchange_service_client.datatypes.MessageMetaDataAndSMEVSignature;
import ru.voskhod.smev.message_exchange_service_client.impl.FileAttachmentImpl;
import ru.voskhod.smev.message_exchange_service_client.impl.FileSystemSMEVCertificateStore;
import ru.voskhod.smev.message_exchange_service_client.impl.KeyPersonalSignerImpl;
import ru.voskhod.smev.message_exchange_service_client.intercept.InterceptorStorage;
import ru.voskhod.crypto.DigitalSignatureFactory;
import ru.voskhod.crypto.KeyStoreWrapper;

import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.File;
import java.io.StringReader;
import java.io.StringWriter;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Интеграционные тесты, демонстрирующие основные сценарии использования клиента СМЭВ.
 * <p/>
 * Пререквизиты:
 * Необходимо зарегистрировать в СМЭВ следующие информационные системы:
 * - Система 1. Поставщик данных. Для этой системы необходимо добавить вид сведений (см. ../../resources/smev-gar-service.xsd) и
 * потребителем указать Систему 2. Параметры созданных сертификатов задать в конфиге (см. настройки с префиксом "provider.")
 * - Система 2. В примерах будет являться потребителем данных.
 * Параметры созданных сертификатов задать в конфиге (см. настройки с префиксом "ov." и "sp.")
 * <p/>
 * Команда для запуска тестов: mvn verify
 */
public class ClientIT extends TestCase {

    static {
        DigitalSignatureFactory.init("JCP");
    }

    /**
     * Клиент СМЭВ поставщика данных
     */
    private MessageExchangeEndpoint providerClient;
    /**
     * Ключи и сертификаты ИС должностного лица потребителя
     */
    private SignatureOperationsClient spSOC;

    /**
     * Клиент СМЭВ потребителя данных
     */
    private MessageExchangeEndpoint consumerClient;

    /**
     * Максимальный размер аттачментов, пересылаемых напрямую, без ftp
     */
    public static final int MTOM_LIMIT = 1024 * 1024;

    /**
     * Файл, меньшего размера чем {@link integration.ClientIT#MTOM_LIMIT}, для проверки передачи файлов через MTOM
     */
    private File smallFile;

    /**
     * Файл, большего размера чем {@link integration.ClientIT#MTOM_LIMIT}, для проверки передачи файлов через FTP
     */
    private File bigFile;

    /**
     * Выполняется перед каждым тестом. Инициализирует клиента
     *
     * @throws Exception в случае ошибки инициализации
     */
    @Override
    protected void setUp() throws Exception {
        // загружаем настройки тестов
        Properties props = new Properties();
        props.load(this.getClass().getClassLoader().getResourceAsStream("integration_tests.properties"));

        // инициализируем хранилище сертификатов СМЭВ
        File dir = new File(props.getProperty("smev.certificates.dir"));
        SMEVCertificateStore.setInstance(new FileSystemSMEVCertificateStore(dir));

        // загружаем ключи и сертификаты ИС потребителя
        SignatureOperationsClient ovSOC = getKeyAndCertificate("ov", props); //органа власти
        spSOC = getKeyAndCertificate("sp", props);

        // создаем клиента СМЭВ для потребителя данных
        consumerClient = MessageExchangeEndpoint.create(
                props.getProperty("smev.url"), //адрес СМЭВ
                props.getProperty("ftp.url"), //FTP адрес для передачи вложений
                ovSOC, // ключ и сертификат органа власти
                MTOM_LIMIT // лимит на суммарный объем файлов, передаваемых в СМЭВ напрямую (не через FTP)
        );

        // создаем клиента СМЭВ для поставщика данных
        SignatureOperationsClient providerSOC = getKeyAndCertificate("provider", props);
        providerClient = MessageExchangeEndpoint.create(
                props.getProperty("smev.url"), //адрес СМЭВ
                props.getProperty("ftp.url"), //FTP адрес для передачи вложений
                providerSOC, // ключ и сертификат органа власти
                MTOM_LIMIT
        );

        // аттачменты
        smallFile = new File(props.getProperty("attachment.file.mtom"));
        if (!smallFile.exists() || (smallFile.length() >= MTOM_LIMIT)) {
            throw new IllegalStateException("Файл для передачи через MTOM указан неверно");
        }
        bigFile = new File(props.getProperty("attachment.file.ftp"));
        if (!bigFile.exists() || (bigFile.length() < MTOM_LIMIT)) {
            throw new IllegalStateException("Файл для передачи через FTP указан неверно");
        }

        //очищаем очереди запросов/ответов
        clearQueues();
    }

    /**
     * Простой пример посылки запроса сервису.
     * Используется встроенный в СМЭВ сервис "Эхо".
     */
    public void testEcho() {
        // в процессе разработки и отладки можно включить трассировку запросов и ответов (по умолчанию выключена)
        InterceptorStorage.getRequest().setIntercept(true);
        InterceptorStorage.getResponse().setIntercept(true);

        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><EchoPlease xmlns=\"urn://x-artefacts-smev-gov-ru/services/echo/1.0\"><MyYell>Это - русский текст</MyYell></EchoPlease>";
        Element dataToSend = stringToElement(xml);
        try {
            String messageID = consumerClient.generateMessageID();
            // отправляем запрос сервису "Эхо"
            consumerClient.sendRequest(messageID, dataToSend, null, null, null);
        } catch (SenderIsNotRegisteredException ex) {
            fail("Система с указанным сертификатом органа власти не зарегистрирована в СМЭВ");
        } catch (SignatureVerificationFaultException ex) {
            fail("Ошибка верификации цифровой подписи");
        } catch (SMEVFailureException ex) {
            fail("Внутренняя ошибка СМЭВ");
        } catch (RecipientIsNotFoundException ex) {
            fail("Ошибка идентификации получателя данных. Возможно неверно указано пространство имен в запросе");
        } catch (InvalidContentException ex) {
            fail("Бизнес-данные не прошли валидацию по схеме вида сведений");
        } catch (BusinessDataTypeIsNotSupportedException ex) {
            fail("Схема для бизнес-данных не зарегистрирована в СМЭВ");
        } catch (AttachmentSizeLimitExceededException ex) {
            fail("Общий размер приложенных файлов превышает ограничение СМЭВ");
        } catch (AccessDeniedException ex) {
            fail("Вашей ИС запрещено посылать запросы такого типа");
        } catch (DestinationOverflowException ex) {
            fail("Очередь запросов к сервису переполнена");
        } catch (Exception ex) {
            fail("Внутренняя ошибка клиентской библиотеки");
        }

        // если трассировка запросов и ответов была включена, то можно посмотреть реально отосланные и полученные данные
        assertTrue("Отправлены неверные данные", InterceptorStorage.getRequest().getString().contains("MyYell"));
        assertTrue("Получен ответ неверного вида", InterceptorStorage.getResponse().getString().contains("SendRequestResponse"));
    }

    /**
     * Тест отправки запроса и получения ответа со стороны потребителя данных, и
     * получение запроса и отправка ответа со стороны поставщика данных
     */
    public void testProvideAndConsume() {
        // отправка запроса потребителем
        try {
            String message = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><CallMeManana xmlns=\"urn://x-artefacts-smev-gov-ru/services/gar/1.0.0\"><Name>Hans</Name></CallMeManana>";
            PersonalSigner signPersonal = KeyPersonalSignerImpl.create(spSOC);
            MessageMetadata meta = sendRequest(consumerClient, message, signPersonal);
            assertEquals("Неверный тип сообщения", MessageTypeType.REQUEST, meta.getMessageType());
        } catch (Exception ex) {
            ex.printStackTrace();
            fail("Ошибка отправки запроса потребителем");
        }

        // получение запроса поставщиком
        Request request = null;
        try {
            // интересуют только запросы с указанным пространством имен и указанным корневым тегом
            QName requestFilter = new QName("urn://x-artefacts-smev-gov-ru/services/gar/1.0.0", "CallMeManana");
            request = receiveRequest(providerClient, requestFilter);
            assertNotNull("Запрос от потребителя не получен", request);
            MessagePrimaryContent mpc = request.getSenderProvidedRequestData().getMessagePrimaryContent();
            assertTrue("Неверные данные в запросе", elementToString(mpc.getAny()).contains("CallMeManana"));
        } catch (Exception ex) {
            ex.printStackTrace();
            fail("Ошибка получения запроса поставщиком");
        }

        //отправка ответа поставщиком
        try {
            String message = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><HereYouAre xmlns=\"urn://x-artefacts-smev-gov-ru/services/gar/1.0.0\"><Phrase>Hans, you are Manana!</Phrase></HereYouAre>";
            MessageMetadata meta = sendResponse(providerClient, request.getReplyTo(), message, null);
            assertEquals("Неверный тип сообщения", MessageTypeType.RESPONSE, meta.getMessageType());
        } catch (Exception ex) {
            ex.printStackTrace();
            fail("Ошибка отправки ответа поставщиком");
        }

        //получение ответа потребителем
        try {
            QName responseFilter = new QName("urn://x-artefacts-smev-gov-ru/services/gar/1.0.0", "HereYouAre");
            Response response = receiveResponse(consumerClient, responseFilter);
            assertNotNull("Ответ на запрос не получен", response);
            MessagePrimaryContent mpc = response.getSenderProvidedResponseData().getMessagePrimaryContent();
            assertTrue("Неверные данные в ответе", elementToString(mpc.getAny()).contains("Hans, you are Manana"));
        } catch (Exception ex) {
            ex.printStackTrace();
            fail("Ошибка получения ответа потребителем");
        }

    }

    /**
     * Тест передачи вложенных файлов с помощью MTOM
     */
    public void testFileSendMTOM() {
        sendFile(smallFile, null);
    }

    /**
     * Тест передачи вложенных файлов с помощью FTP
     */
    public void testFileSendFTP() {
        sendFile(bigFile, null);
    }

    /**
     * Отправляет сообщение с вложением, проверяет правильность получения файла на стороне получателя
     *
     * @param attachmentFile файл для отправки
     * @param spSigner ключи ЭП-СП (null если не использовать ЭП-СП)
     */
    private void sendFile(File attachmentFile, SignatureOperationsClient spSigner) {
        // отправка запроса с вложенными файлами
        String mimeType = SomeMimeTypes.guessMimeType(attachmentFile);
        try {
            String messageId = consumerClient.generateMessageID();
            List<InAttachment> attachmentList = new ArrayList<InAttachment>();
            InAttachment attachment = new FileAttachmentImpl(attachmentFile, mimeType);
            attachment.setSignPersonal(spSigner);
            attachmentList.add(attachment);
            String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><CallMeManana xmlns=\"urn://x-artefacts-smev-gov-ru/services/gar/1.0.0\"><Name>Hans</Name></CallMeManana>";
            PersonalSigner signPersonal = KeyPersonalSignerImpl.create(spSigner);
            consumerClient.sendRequest(messageId, stringToElement(xml), signPersonal, null, attachmentList);
        } catch (Exception ex) {
            ex.printStackTrace();
            fail("Ошибка отправки запроса с вложениями");
        }

        //получение запроса с вложенными файлами
        try {
            QName requestFilter = new QName("urn://x-artefacts-smev-gov-ru/services/gar/1.0.0", "CallMeManana");
            GetRequestResponse reqResp = providerClient.getRequest(requestFilter);
            if ((reqResp == null) || (reqResp.getRequestMessage() == null)) {
                fail("Запрос от потребителя не получен");
            }
            providerClient.ack(reqResp);
            List<OutAttachment> attachments = providerClient.getAttachments(reqResp);
            assertEquals("Неверное количество вложений в запросе", 1, attachments.size());
            OutAttachment attachment = attachments.get(0);
            assertEquals("Неверный MIME тип вложения", mimeType, attachment.getMimeType());
        } catch (Exception ex) {
            ex.printStackTrace();
            fail("Ошибка получения запроса поставщиком");
        }
    }

    /**
     * Отправка сообщения (запроса) в СМЭВ
     *
     * @param client  клиент СМЭВ
     * @param message данные для отправки
     * @return метаданные отправленного сообщения
     * @throws Exception если отправка не удалась
     */
    private static MessageMetadata sendRequest(MessageExchangeEndpoint client, String message, PersonalSigner signPersonal) throws Exception {
        String messageId = client.generateMessageID();
        MessageMetaDataAndSMEVSignature result = client.sendRequest(messageId, stringToElement(message), signPersonal, null, null);
        return result.getMessageMetadata();
    }

    /**
     * Получение запроса
     *
     * @param client        клиент СМЭВ
     * @param requestFilter фильтр по типу запроса, либо null для получения запросов любого типа
     * @return полученный запрос
     * @throws Exception если возникла ошибка получения запроса
     */
    private static Request receiveRequest(MessageExchangeEndpoint client, QName requestFilter) throws Exception {
        GetRequestResponse reqResp = client.getRequest(requestFilter);
        if ((reqResp == null) || (reqResp.getRequestMessage() == null)) {
            return null;
        }
        client.ack(reqResp); // подтверждаем получение запроса
        return reqResp.getRequestMessage().getRequest();
    }

    /**
     * Отправляет ответ на запрос
     *
     * @param client  клиент СМЭВ
     * @param address адрес получателя ответа
     * @param message данные для отправки
     * @return метаданные отправленного сообщения
     * @throws Exception если отправка не удалась
     */
    private static MessageMetadata sendResponse(MessageExchangeEndpoint client, String address, String message, PersonalSigner signPersonal) throws Exception {
        String replyMessageId = client.generateMessageID();
        MessageMetaDataAndSMEVSignature result = client.sendResponse(replyMessageId, address, stringToElement(message), signPersonal, null);
        return result.getMessageMetadata();
    }

    /**
     * Получение ответа на запрос
     *
     * @param client         клиент СМЭВ
     * @param responseFilter фильтр по типу ответа, либо null для получения ответов любого типа
     * @return полученный ответ
     * @throws Exception если возникла ошибка получения ответа
     */
    private static Response receiveResponse(MessageExchangeEndpoint client, QName responseFilter) throws Exception {
        GetResponseResponse resResp = client.getResponse(responseFilter);
        if ((resResp == null) || (resResp.getResponseMessage() == null)) {
            return null;
        }
        client.ack(resResp); // подтверждаем получение ответа
        return resResp.getResponseMessage().getResponse();
    }

    /**
     * Преобразует указанный текст в xml документ и возвращает корневой элемент полученного документа
     *
     * @param xml текст xml файла
     * @return корневой элемент документа
     */
    private static Element stringToElement(String xml) {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new InputSource(new StringReader(xml)));
            return document.getDocumentElement();
        } catch (Exception ex) {
            throw new IllegalArgumentException("Cannot transform specified string to xml document", ex);
        }
    }

    /**
     * Преобразует указанный xml элемент в строку
     *
     * @param element элемент для преобразования
     * @return строковое представление указанного элемента
     */
    private static String elementToString(Element element) {
        try {
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            StringWriter writer = new StringWriter();
            StreamResult result = new StreamResult(writer);
            DOMSource source = new DOMSource(element);
            transformer.transform(source, result);
            return writer.toString();
        } catch (Exception ex) {
            throw new IllegalStateException("Cannot transform xml element to string", ex);
        }
    }

    /**
     * Загружает приватный ключ и сертификат из хранилища и возвращает их
     *
     * @param prefix префикс для названий свойств в указанных настройках
     * @param config настройки
     * @return пару: приватный ключ и сертификат
     */
    private static SignatureOperationsClient getKeyAndCertificate(String prefix, Properties config) throws Exception {
        KeyStoreWrapper keyStore = DigitalSignatureFactory.getKeyStoreWrapper();
        String alias = config.getProperty(prefix + ".container.alias");
        String password = config.getProperty(prefix + ".container.password");
        PrivateKey privateKey = keyStore.getPrivateKey(alias, null);
        X509Certificate certificate = keyStore.getX509Certificate(alias);
        return new SignatureOperationsClient(privateKey, certificate);
    }

    /**
     * Очищает очередь запросов поставщика и очередь ответов потребителя
     */
    private void clearQueues() {
        // очередь поставщика
        while (true) {
            try {
                GetRequestResponse grr = providerClient.getRequest(null);
                if ((grr == null) || (grr.getRequestMessage() == null)) {
                    break;
                }
                providerClient.ack(grr);
            } catch (Exception ex) {
                ex.printStackTrace();
                break;
            }
        }
        // очередь потребителя
        while (true) {
            try {
                GetResponseResponse grr = consumerClient.getResponse(null);
                if ((grr == null) || (grr.getResponseMessage() == null)) {
                    break;
                }
                consumerClient.ack(grr);
            } catch (Exception ex) {
                ex.printStackTrace();
                break;
            }
        }
    }
}
